
import type { Wall, Member3D, Floor } from '../types';
import { generateWallMembers } from './geometryService';

const studDepths: { [key: string]: number } = {
    '2x4': 3.5, '2x6': 5.5
};

const generateComponentDefinitionScript = (member: Member3D, component_def_name: string) => {
    // Geometry is drawn relative to the component's origin.
    // The component's origin will be its bottom-front-left corner.
    // My app dimensions w, h, d => SketchUp dimensions x=w, z=h, y=d
    return `
    begin
        comp_def = definitions.add("${component_def_name}")
        comp_def.description = "Generated by Framing Calculator Pro"
        points = [
            Geom::Point3d.new(0, 0, 0),
            Geom::Point3d.new(${member.w}, 0, 0),
            Geom::Point3d.new(${member.w}, ${member.d}, 0),
            Geom::Point3d.new(0, ${member.d}, 0)
        ]
        face = comp_def.entities.add_face(points)
        if face
            face.reverse! if face.normal.z < 0
            face.pushpull(${member.h})
            material_to_apply = materials_map["${member.type}"]
            if material_to_apply
                comp_def.entities.each { |e| e.material = material_to_apply if e.is_a?(Sketchup::Face) }
            else
                 puts "Material not found for type: ${member.type}"
            end
        else
            puts "Failed to create face for ${component_def_name}"
        end
        component_map["${member.name.replace(/"/g, '\\"')}"] = comp_def
    rescue => e
        puts "Error creating component definition for ${component_def_name.replace(/'/g, "\\'\\'")}: " + e.message
    end
  `;
}

const getLayerForMember = (member: Member3D): string => {
    switch(member.type) {
        case 'header': return 'Headers';
        case 'blocking': return 'Blocking';
        case 'sheathing': return 'Sheathing';
        case 'plate':
        case 'pt-plate':
        case 'sill':
            return 'Plates';
        case 'king-jack':
            return member.name.toLowerCase().includes('king') ? 'Kings' : 'Jacks';
        case 'stud':
        case 'cripple':
        default:
            return 'Studs';
    }
};

const generateComponentInstanceScript = (member: Member3D, parent_group_name: string) => {
    // My app's coordinate system: X right, Y down, Z into screen.
    // SketchUp's coordinate system: X right (red), Y into screen (green), Z up (blue).
    // Mapping: Sketchup.x = my.x; Sketchup.y = my.z; Sketchup.z = -my.y;
    
    // Component origin is bottom-front-left.
    // My member position x,y,z is top-front-left.
    // To get the bottom for SketchUp Z coord: -(member.y + member.h).
    const skp_x = member.x;
    const skp_y = member.z;
    const skp_z = -(member.y + member.h);
    const layerName = getLayerForMember(member);
    
    return `
    begin
        comp_def = component_map["${member.name.replace(/"/g, '\\"')}"]
        if comp_def
            transform = Geom::Transformation.new([${skp_x}, ${skp_y}, ${skp_z}])
            instance = ${parent_group_name}.entities.add_instance(comp_def, transform)
            instance.layer = "${layerName}"
        else
            puts "Could not find component definition for ${member.name.replace(/'/g, "\\'\\'")}"
        end
    rescue => e
        puts "Error creating instance for ${member.id.replace(/'/g, "\\'\\'")}: " + e.message
    end
  `;
}

export const generateSketchUpScript = (walls: Wall[], floors?: Floor[]): string => {
    let script = `
# SketchUp Framing Script generated by Framing Calculator Pro
# To use: In SketchUp, go to Window > Ruby Console, then paste this entire script and press Enter.

require 'sketchup.rb'

model = Sketchup.active_model
entities = model.entities
materials = model.materials
definitions = model.definitions
layers = model.layers

# Define materials
def add_material(materials, name, color, alpha = 1.0)
  material = materials[name]
  unless material
    material = materials.add(name)
    material.color = color
    material.alpha = alpha
  end
  return material
end

materials_map = {
  "plate" => add_material(materials, "Plate", "Goldenrod"),
  "pt-plate" => add_material(materials, "PT Plate", "DarkGreen"),
  "stud" => add_material(materials, "Stud", "Tan"),
  "king-jack" => add_material(materials, "KingJackStud", "SaddleBrown"),
  "header" => add_material(materials, "Header", "DarkRed"),
  "sill" => add_material(materials, "Sill", "Goldenrod"),
  "cripple" => add_material(materials, "Cripple", "Tan"),
  "blocking" => add_material(materials, "Blocking", "DarkOrange"),
  "sheathing" => add_material(materials, "Sheathing", "Wheat", 0.5)
}

# Create Layers
required_layers = ["Plates", "Studs", "Kings", "Jacks", "Headers", "Blocking", "Sheathing"]
required_layers.each do |layer_name|
  layers.add(layer_name) unless layers[layer_name]
end

model.start_operation('Create Framing Project', true)

Z_AXIS = Geom::Vector3d.new(0, 0, 1)

# --- Component Definitions ---
component_map = {}
`;

    // 1. Get all unique members to create component definitions
    const uniqueMembers = new Map<string, Member3D>();
    walls.forEach(wall => {
        const members = generateWallMembers(wall.details);
        members.forEach(member => {
            if (!uniqueMembers.has(member.name)) {
                uniqueMembers.set(member.name, member);
            }
        });
    });

    // 2. Generate script to create component definitions
    uniqueMembers.forEach(member => {
        const componentDefName = member.name.replace(/"/g, "'");
        script += generateComponentDefinitionScript(member, componentDefName);
    });
    
    // --- Wall Creation from Component Instances ---
    let pdfToInchesScale = 1.0;
    const scaleReferenceWall = walls.find(w => w.pdfPosition && w.details.wallLength > 0);

    if (scaleReferenceWall) {
        const { start, end } = scaleReferenceWall.pdfPosition!;
        const pdfDistance = Math.hypot(end.x - start.x, end.y - start.y);
        if (pdfDistance > 0.001) {
            pdfToInchesScale = scaleReferenceWall.details.wallLength / pdfDistance;
        }
    }

    const positionedWalls = walls.filter(w => w.pdfPosition);
    const unpositionedWalls = walls.filter(w => !w.pdfPosition);
    
    // Create map for floor elevations
    const floorMap: Record<string, number> = {};
    if (floors) {
        floors.forEach(f => floorMap[f.id] = f.elevation);
    }

    positionedWalls.forEach((wall, index) => {
        const members = generateWallMembers(wall.details);
        const { start, end } = wall.pdfPosition!;
        const wallGroupName = `wall_group_p${index}`;

        // Scale and transform coordinates for SketchUp
        const skp_start_x = start.x * pdfToInchesScale;
        const skp_start_y = -start.y * pdfToInchesScale; // Y is inverted for SketchUp
        const skp_end_x = end.x * pdfToInchesScale;
        const skp_end_y = -end.y * pdfToInchesScale;
        
        const angleRad = Math.atan2(skp_end_y - skp_start_y, skp_end_x - skp_start_x);
        
        // Handle floor elevation
        let elevation = 0;
        if (wall.floorId && floorMap[wall.floorId]) {
            elevation = floorMap[wall.floorId];
        }

        script += `
# Positioned Wall: ${wall.name.replace(/'/g, "\\'")}
${wallGroupName} = entities.add_group
${wallGroupName}.name = "${wall.name.replace(/"/g, '\\"')}"
`;
        members.forEach(member => {
            script += generateComponentInstanceScript(member, wallGroupName);
        });
        script += `
begin
    rotation = Geom::Transformation.rotation(ORIGIN, Z_AXIS, ${angleRad})
    translation = Geom::Transformation.translation(Geom::Vector3d.new(${skp_start_x}, ${skp_start_y}, ${elevation}))
    ${wallGroupName}.transform!(translation * rotation)
rescue => e
    puts "Error transforming wall ${wall.name.replace(/'/g, "\\'\\'")}: " + e.message
end
`;
    });

    let unpositionedGridYOffset = 0;
    if (positionedWalls.length > 0) {
        let maxY_pdf = -Infinity;
        positionedWalls.forEach(wall => {
            const { start, end } = wall.pdfPosition!;
            maxY_pdf = Math.max(maxY_pdf, start.y, end.y);
        });
        const skp_most_negative_y = -maxY_pdf * pdfToInchesScale;
        unpositionedGridYOffset = skp_most_negative_y - 240; // Place 20ft "behind"
    }

    const GRID_COLUMNS = 3;
    const WALL_SPACING = 120; // 10ft
    const ROW_SPACING = 240; // 20ft

    let currentXOffset = 0;
    let currentYOffset = unpositionedGridYOffset;
    let maxRowDepth = 0;

    unpositionedWalls.forEach((wall, index) => {
        if (index > 0 && index % GRID_COLUMNS === 0) {
            currentXOffset = 0;
            currentYOffset -= (maxRowDepth + ROW_SPACING); // Move to the next row "behind"
            maxRowDepth = 0;
        }

        const members = generateWallMembers(wall.details);
        const wallGroupName = `wall_group_u${index}`;
        
        script += `
# Unpositioned Wall: ${wall.name.replace(/'/g, "\\'")}
${wallGroupName} = entities.add_group
${wallGroupName}.name = "${wall.name.replace(/"/g, '\\"')}"
`;
        members.forEach(member => {
            script += generateComponentInstanceScript(member, wallGroupName);
        });

        script += `
begin
    translation = Geom::Transformation.translation(Geom::Vector3d.new(${currentXOffset}, ${currentYOffset}, 0))
    ${wallGroupName}.transform!(translation)
rescue => e
    puts "Error transforming wall ${wall.name.replace(/'/g, "\\'\\'")}: " + e.message
end
`;
        const wallWidth = wall.details.wallLength;
        const studDepth = studDepths[wall.details.studSize];
        currentXOffset += wallWidth + WALL_SPACING;
        maxRowDepth = Math.max(maxRowDepth, studDepth);
    });

    script += `
model.commit_operation
UI.messagebox('Framing project created successfully!')
`;

    return script;
};
