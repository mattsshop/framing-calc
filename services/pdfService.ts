
import jsPDF from 'jspdf';
import autoTable from 'jspdf-autotable';
import type { Wall, FramingMaterials, WallDetails } from '../types';

const formatLengthForPdf = (length: number | string) => {
    if (typeof length === 'string') return length;
    if (length > 0) return `${length / 12}'`;
    return 'Sheet';
};

const addMaterialTablesToPdf = (doc: jsPDF, materials: FramingMaterials, startY: number, format: 'both' | 'breakdown' | 'consolidated' | 'by-floor'): number => {
    let currentY = startY;
    
    const hasBreakdown = format === 'both' || format === 'breakdown';
    const hasConsolidated = format === 'both' || format === 'consolidated';
    const hasFloor = format === 'both' || format === 'by-floor';

    // 1. By Floor
    if (hasFloor && materials.byFloor) {
        doc.setFontSize(14);
        doc.text('Material List by Floor', 14, currentY);
        currentY += 10;

        for (const floorId in materials.byFloor) {
            const { floorName, materials: floorMaterials } = materials.byFloor[floorId];
            if (floorMaterials.length === 0) continue;

            const tableData = floorMaterials.map(item => [item.quantity.toString(), item.description, formatLengthForPdf(item.length)]);
             const tableHeight = (tableData.length + 1) * 12 + 15;

            if (currentY + tableHeight > doc.internal.pageSize.getHeight() - 40) {
                doc.addPage();
                currentY = 40;
            }

            doc.setFontSize(11);
            doc.setFont('helvetica', 'bold');
            doc.text(floorName, 14, currentY);
            currentY += 5;

            autoTable(doc, {
                startY: currentY,
                head: [['Qty', 'Description', 'Length']],
                body: tableData,
                theme: 'striped',
                headStyles: { fillColor: [46, 204, 113] }, // Emerald green for floors
                columnStyles: { 0: { cellWidth: 20 }, 2: { halign: 'right' } }
            });
            currentY = (doc as any).lastAutoTable.finalY + 15;
        }
    }

    // 2. Breakdown by Wall
    if (hasBreakdown) {
        if (hasFloor && (currentY + 60 > doc.internal.pageSize.getHeight() - 40)) {
             doc.addPage();
             currentY = 40;
        }

        doc.setFontSize(14);
        doc.text('Material Breakdown by Wall', 14, currentY);
        currentY += 10;

        for (const wallId in materials.byWall) {
            const { wallName, materials: wallMaterials } = materials.byWall[wallId];
            if (wallMaterials.length === 0) continue;

            const tableData = wallMaterials.map(item => [item.quantity.toString(), item.description, formatLengthForPdf(item.length)]);
            const tableHeight = (tableData.length + 1) * 12 + 15;

            if (currentY + tableHeight > doc.internal.pageSize.getHeight() - 40) {
                doc.addPage();
                currentY = 40;
            }

            doc.setFontSize(11);
            doc.setFont('helvetica', 'bold');
            doc.text(wallName, 14, currentY);
            currentY += 5;

            autoTable(doc, {
                startY: currentY,
                head: [['Qty', 'Description', 'Length']],
                body: tableData,
                theme: 'striped',
                headStyles: { fillColor: [80, 80, 90] },
                columnStyles: { 0: { cellWidth: 20 }, 2: { halign: 'right' } }
            });
            currentY = (doc as any).lastAutoTable.finalY + 15;
        }
    }

    // 3. Consolidated Total
    if (hasConsolidated) {
        if ((hasBreakdown || hasFloor) && (currentY + 80 > doc.internal.pageSize.getHeight() - 40)) {
            doc.addPage();
            currentY = 40;
        }
        doc.setFontSize(14);
        doc.text('Consolidated Project Total', 14, currentY);
        currentY += 10;
        const consolidatedTableData = materials.list.map(item => [item.quantity.toString(), item.description, formatLengthForPdf(item.length)]);
        autoTable(doc, {
            startY: currentY,
            head: [['Qty', 'Description', 'Length']],
            body: consolidatedTableData,
            theme: 'grid',
            headStyles: { fillColor: [34, 49, 63] },
            columnStyles: { 0: { cellWidth: 40, halign: 'center' }, 2: { cellWidth: 60, halign: 'right' } }
        });
        currentY = (doc as any).lastAutoTable.finalY;
    }

    return currentY;
};


export const generateMaterialListPdf = (walls: Wall[], materials: FramingMaterials, format: 'both' | 'breakdown' | 'consolidated' | 'by-floor') => {
  const doc = new jsPDF();
  const today = new Date().toLocaleDateString();

  doc.setFontSize(20); doc.text('Framing Project Order List', 14, 22);
  doc.setFontSize(11); doc.text(`Generated by Framing Calculator Pro on ${today}`, 14, 28);
  
  doc.setFontSize(14); doc.text('Project Summary', 14, 40);
  autoTable(doc, {
    startY: 44,
    head: [['Parameter', 'Value']],
    body: [['Total Walls', walls.length.toString()], ['Total Linear Feet', `~${Math.round(materials.totalLinearFeet)} ft`]],
    theme: 'striped', headStyles: { fillColor: [41, 128, 185] },
  });

  let finalY = (doc as any).lastAutoTable.finalY || 80;
  
  finalY = addMaterialTablesToPdf(doc, materials, finalY + 15, format);
  
  if(materials.proTip) {
    if (finalY + 40 > doc.internal.pageSize.getHeight() - 40) doc.addPage();
    doc.setFontSize(12); doc.setFont('helvetica', 'bold');
    doc.text('Pro Tip:', 14, finalY + 15);
    doc.setFont('helvetica', 'normal');
    doc.text(doc.splitTextToSize(materials.proTip, 180), 14, finalY + 21);
  }

  doc.save(`framing_project_list_${Date.now()}.pdf`);
};

const PLATE_THICKNESS = 1.5;
const STUD_THICKNESS = 1.5;
const headerHeights: { [key: string]: number } = { '2x6': 5.5, '2x8': 7.25, '2x10': 9.25, '2x12': 11.25 };
const colors = { ptPlate: '#15803d', plate: '#ca8a04', stud: '#a16207', kingJack: '#854d0e', header: '#b91c1c', roWindow: '#7dd3fc55', roDoor: '#fb923c55' };

export const drawWallOnCanvas = (canvas: HTMLCanvasElement, details: WallDetails) => {
    const ctx = canvas.getContext('2d');
    if (!ctx) return;
    const { wallLength, wallHeight, studSpacing, openings, doubleTopPlate, studsOnCenter } = details;
    if (wallLength <= 0) return;

    const canvasWidth = 800, scale = canvasWidth / wallLength, canvasHeight = wallHeight * scale;
    canvas.width = canvasWidth; canvas.height = canvasHeight;
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    const drawMember = (x: number, y: number, w: number, h: number, color: string) => { ctx.fillStyle = color; ctx.fillRect(x, y, w, h); };

    const topPlateHeight = (doubleTopPlate ? 2 : 1) * PLATE_THICKNESS;
    const bottomPlateHeight = PLATE_THICKNESS;

    drawMember(0, 0, canvasWidth, topPlateHeight * scale, colors.plate);
    drawMember(0, canvasHeight - (bottomPlateHeight * scale), canvasWidth, bottomPlateHeight * scale, details.pressureTreatedBottomPlate ? colors.ptPlate : colors.plate);

    const studHeight = wallHeight - topPlateHeight - bottomPlateHeight, studY = topPlateHeight * scale, studH = studHeight * scale, studW = STUD_THICKNESS * scale;

    const openingLayouts = openings.flatMap(op => Array(op.quantity).fill(op));
    const totalOpeningFrameWidth = openingLayouts.reduce((acc, op) => acc + op.width + 2 * (op.kingStudsPerSide + op.jackStudsPerSide) * STUD_THICKNESS, 0);
    const spacing = Math.max(0, (wallLength - totalOpeningFrameWidth) / (openingLayouts.length + 1));
    const openingPositions: { start: number, end: number }[] = [];
    let currentX = spacing;
    openingLayouts.forEach(opening => {
        const frameWidth = opening.width + 2 * (opening.kingStudsPerSide + opening.jackStudsPerSide) * STUD_THICKNESS;
        openingPositions.push({ start: currentX, end: currentX + frameWidth });
        currentX += frameWidth + spacing;
    });

    for (let i = 0; i <= Math.ceil(wallLength / studSpacing); i++) {
        const studCenterPos = i * studSpacing;
        if (!openingPositions.some(pos => studCenterPos >= pos.start && studCenterPos <= pos.end)) {
            const baseLeft = studCenterPos - (studsOnCenter * STUD_THICKNESS / 2);
            for (let j = 0; j < studsOnCenter; j++) drawMember((baseLeft + j * STUD_THICKNESS) * scale, studY, studW, studH, colors.stud);
        }
    }

    currentX = spacing;
    openingLayouts.forEach(opening => {
        const frameStart = currentX, headerH = headerHeights[opening.headerSize] * scale;
        const kingWidth = opening.kingStudsPerSide * STUD_THICKNESS, jackWidth = opening.jackStudsPerSide * STUD_THICKNESS;
        
        for (let k = 0; k < opening.kingStudsPerSide; k++) drawMember((frameStart + k*STUD_THICKNESS) * scale, studY, studW, studH, colors.kingJack);
        for (let j = 0; j < opening.jackStudsPerSide; j++) drawMember((frameStart + kingWidth + j*STUD_THICKNESS) * scale, studY + headerH, studW, studH - headerH, colors.kingJack);
        
        const rightFrameStart = frameStart + kingWidth + jackWidth + opening.width;
        for (let j = 0; j < opening.jackStudsPerSide; j++) drawMember((rightFrameStart + j*STUD_THICKNESS) * scale, studY + headerH, studW, studH - headerH, colors.kingJack);
        for (let k = 0; k < opening.kingStudsPerSide; k++) drawMember((rightFrameStart + jackWidth + k*STUD_THICKNESS) * scale, studY, studW, studH, colors.kingJack);
        
        const headerX = (frameStart + kingWidth) * scale, headerW = (opening.width + 2 * jackWidth) * scale;
        drawMember(headerX, topPlateHeight * scale, headerW, headerH, colors.header);
        
        const roughOpeningX = (frameStart + kingWidth + jackWidth) * scale;
        drawMember(roughOpeningX, (topPlateHeight * scale) + headerH, opening.width * scale, opening.height * scale, opening.type === 'window' ? colors.roWindow : colors.roDoor);
        if (opening.type === 'window') {
            const sillY = (topPlateHeight * scale) + headerH + (opening.height * scale);
            drawMember(headerX, sillY, headerW, PLATE_THICKNESS * scale, colors.plate);
        }
        currentX += opening.width + 2 * (kingWidth + jackWidth) + spacing;
    });
};

export const generateMaterialReportPdf = (walls: Wall[], materials: FramingMaterials, wallImages: string[]) => {
    const doc = new jsPDF('p', 'pt', 'a4');
    
    doc.deletePage(1); doc.addPage();
    const today = new Date().toLocaleDateString();

    doc.setFontSize(20); doc.text('Framing Project Report', 40, 50);
    doc.setFontSize(11); doc.text(`Generated by Framing Calculator Pro on ${today}`, 40, 60);
    
    doc.setFontSize(14); doc.text('Project Summary', 40, 85);
    autoTable(doc, {
        startY: 95, head: [['Parameter', 'Value']], body: [['Total Walls', walls.length.toString()], ['Total Linear Feet', `~${Math.round(materials.totalLinearFeet)} ft`]],
        theme: 'striped', headStyles: { fillColor: [41, 128, 185] }, margin: { left: 40, right: 40 },
    });
    
    let finalY = (doc as any).lastAutoTable.finalY || 150;
    
    finalY = addMaterialTablesToPdf(doc, materials, finalY + 25, 'both');

    if(materials.proTip) {
        if (finalY + 40 > doc.internal.pageSize.getHeight() - 40) doc.addPage();
        doc.setFontSize(12); doc.setFont('helvetica', 'bold'); doc.text('Pro Tip:', 40, finalY + 25);
        doc.setFont('helvetica', 'normal'); doc.text(doc.splitTextToSize(materials.proTip, (doc.internal.pageSize.getWidth() - 80)), 40, finalY + 40);
    }

    if (walls.length > 0) {
        doc.addPage();
        doc.setFontSize(20); doc.text('Wall Diagrams', 40, 50);
        let currentY = 80;
        walls.forEach((wall, index) => {
            const imageData = wallImages[index];
            if (imageData) {
                const imgProps = doc.getImageProperties(imageData);
                const aspect = imgProps.height / imgProps.width;
                const imgWidth = doc.internal.pageSize.getWidth() - 80;
                const imgHeight = imgWidth * aspect;
                if (currentY + imgHeight + 40 > doc.internal.pageSize.getHeight()) {
                    doc.addPage(); doc.setFontSize(20); doc.text('Wall Diagrams (continued)', 40, 50);
                    currentY = 80;
                }
                doc.setFontSize(14); doc.text(wall.name, 40, currentY);
                doc.addImage(imageData, 'PNG', 40, currentY + 12, imgWidth, imgHeight);
                currentY += imgHeight + 40;
            }
        });
    }
    doc.save(`framing_project_report_${Date.now()}.pdf`);
};
